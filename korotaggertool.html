<!DOCTYPE html>
<html>

<head>
    <title>Korotagger tool</title>
    <script src="historymanager.js"></script>
    <script src="util.js"></script>
    <style>
        .row {
            display: flex;
        }

        .column {
            flex: 50%;
        }

        .tagslist {
            overflow: auto;
            height: 500px;
        }

        #output {
            overflow: scroll;
        }
    </style>
</head>

<body>
    <div class="row">
        <div class="column">
            <button id="convert">Load from !tags</button><br>
            <textarea id="input" rows="5" cols="50" placeholder="Tags to load go here"></textarea>

            <div id="undoredocontainer">
                <button id="undobutton">Undo</button>
                <button id="redobutton">Redo</button>
            </div>
            <button id="addbutton">Add New</button>
            <div id="taglist">
                <h1>JavaScript is required.</h1>
            </div>
        </div>
        <div class="column">
            <div id="player"></div>
            <form action="#" id="videoinputform">
                <input id="videoinput" value="https://www.youtube.com/live/F8pEYNY_n0c" size="40" />
                <button id="videoinputsubmit" type="submit">Load Video</button>
            </form>
            <form action="#" id="videotimeform">
                <button id="backonesecond">-1s</button>
                <input id="timedisplay" value="0:00" />
                <button id="forwardonesecond">+1s</button>
                <button id="videotimesubmit" type="submit">Jump to Time</button>
            </form>
            <textarea id="output" rows="20" cols="80" placeholder="Output appears here..."></textarea>
        </div>
    </div>


    <script src="listrenderer.js"></script>
    <script>
        const convert_button = document.getElementById("convert");
        const addbutton = document.getElementById("addbutton");
        const input_textarea = document.getElementById("input");
        const output_textarea = document.getElementById("output");
        const videoid_input = document.getElementById("videoinput");
        const videoidinput_form = document.getElementById("videoinputform");
        const timedisplay = document.getElementById("timedisplay");
        const videotime_form = document.getElementById("videotimeform");
        const backonesecond = document.getElementById("backonesecond");
        const forwardonesecond = document.getElementById("forwardonesecond");
        const taglist = document.getElementById("taglist");
        const undobutton = document.getElementById("undobutton");
        const redobutton = document.getElementById("redobutton");

        let player;
        let tagsJson = [{
            "text": "",
            "time": null
        }];

        renderTagList();

        convert_button.onclick = ev => {
            tagsJson = parseTags(input_textarea.value);
            if (tagsJson.length > 0 && tagsJson[0].time === null || isNaN(tagsJson[0].time)) {
                // Attempt to load a video
                const videoId = getIdFromUrl(tagsJson[0].text);
                if (videoId !== null) {
                    loadVideo(videoId);
                }
            }
            newHistory(tagsJson);
            renderTagList();
            const output = renderPreferred(tagsJson);
            output_textarea.value = output;
        };

        addbutton.onclick = ev => {
            tagsJson.unshift({
                "text": "",
                "time": null
            })
            addToHistory(tagsJson);
            renderTagList();
        }

        videoidinput_form.onsubmit = ev => {
            loadVideoFromUrl(videoid_input.value);
            ev.preventDefault();
        }

        videotime_form.onsubmit = ev => {
            const seconds = smartTimestampToSeconds(timedisplay.value);
            if (isNaN(seconds)) {
                // timedisplay.value = "Invalid timestamp.";
                updateVideoTimeDisplay();
                ev.preventDefault();
                return false;
            }
            player.seekTo(seconds, true);
            ev.preventDefault();
        }

        backonesecond.onclick = ev => {
            let newtime = getVideoTime() - 1;
            if (newtime < 0) {
                newtime = 0;
            }
            timedisplay.value = secondsToTimestamp(newtime);
            player.seekTo(newtime, true);
        }

        forwardonesecond.onclick = ev => {
            let newtime = getVideoTime() + 1;
            timedisplay.value = secondsToTimestamp(newtime);
            player.seekTo(newtime, true);
        }

        undobutton.onclick = ev => {
            const newstate = goBackInHistory();
            if (newstate !== null) {
                tagsJson = newstate;
                renderTagList();
                const output = renderPreferred(tagsJson);
                output_textarea.value = output;
            }
        }

        redobutton.onclick = ev => {
            const newstate = goForwardInHistory();
            if (newstate !== null) {
                tagsJson = newstate;
                renderTagList();
                const output = renderPreferred(tagsJson);
                output_textarea.value = output;
            }
        }

        // 2. This code loads the IFrame Player API code asynchronously.
        const tag = document.createElement('script');

        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // 3. This function creates an <iframe> (and YouTube player)
        //    after the API code downloads.
        function onYouTubeIframeAPIReady() {

            player = new YT.Player('player', {
                height: '390',
                width: '640',
                videoId: getIdFromUrl(videoid_input.value),
                playerVars: {
                    'playsinline': 1
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // 4. The API will call this function when the video player is ready.
        function onPlayerReady(event) {
            updateVideoTimeDisplay();
            event.target.stopVideo();
        }

        // 5. The API calls this function when the player's state changes.
        //    The function indicates that when playing a video (state=1),
        //    the player should update the timestamp every second.
        let secondsUpdateInterval = null;
        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.PLAYING && !secondsUpdateInterval) {
                secondsUpdateInterval = setInterval(updateVideoTimeDisplay, 10);
            } else {
                if (secondsUpdateInterval) {
                    clearInterval(secondsUpdateInterval);
                    secondsUpdateInterval = null;
                }
            }
        }

        function loadVideoFromUrl(url) {
            loadVideo(getIdFromUrl(url));
        }

        function loadVideo(id) {
            player.loadVideoById(id);
            player.stopVideo();
        }

        function stopVideo() {
            player.stopVideo();
        }

        function getVideoTime() {
            return Math.floor(player.getCurrentTime());
        }

        function updateVideoTimeDisplay() {
            timedisplay.value = secondsToTimestamp(getVideoTime());
        }

        function updateTagsWithHistory(newTagJson) {
            addToHistory(newTagJson);
            tagsJson = newTagJson;
        }

        function renderTagList() {
            const tags = renderTags(tagsJson, (t) => {
                updateTagsWithHistory(t);
                renderTagList();
                const output = renderPreferred(tagsJson);
                output_textarea.value = output;
            }, (time) => player.seekTo(time));
            taglist.innerHTML = "";
            taglist.appendChild(tags);
        }
    </script>
</body>

</html>